server {
	listen 443 ssl;		
	listen [::]:443 ssl;
	server_name localhost;
	ssl_certificate /etc/nginx/ssl/server.crt;
	ssl_certificate_key /etc/nginx/ssl/server.key;

	# Root of your built application
	# Points to the distribution = the build folder = the compiled frontend assets ready to serve
    root /app/dist;
	
	# Default file to serve
	index index.html;

	# Serve static files efficiently:
	# if a file matching the request exists (like /styles/main.css or /main.js), serve it
	# if not, fallback to /index.html
	location / {
		try_files $uri $uri/ /index.html;
	}

	# MIME types and caching for static assets
	# Sets them to be cached for a year (expires 1y)
	# Adds a Cache-Control header so browsers don’t re-download them unnecessarily (improves performance dramatically)
	# Request to them are not logged in /var/log/nginx/access.log, noisy and unnecessary
	location ~* \.(?:css|js|mjs|ico|png|jpg|jpeg|gif|svg|webp|woff2?)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
        access_log off;
    }

	# To prevent access to hidden files (like .env)
	location ~ /\. {
        deny all;
    }	

	location /api/algo/ {
		proxy_pass http://algo/;
		proxy_http_version 1.1;
		proxy_set_header Upgrade $http_upgrade;
		proxy_set_header Connection "upgrade";
		proxy_set_header Host $host;
		proxy_set_header X-Real-IP $remote_addr;
		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		proxy_set_header X-Forwarded-Proto $scheme;
	}

	location /api/data/ {
		proxy_pass http://data/;
		proxy_set_header Host $host;
		proxy_set_header X-Real-IP $remote_addr;
		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		proxy_set_header X-Forwarded-Proto $scheme;
		limit_except GET POST PATCH DELETE {
			deny all;
		}
	}	
}

# HTTP Server (Port 80) redirects to HTTPS
# Redirect permanent (301) all HTTP traffic to HTTPS
server {
	listen 80; # Listen on port 80 for HTTP 
	listen [::]:80;
	server_name localhost;
	return 301 https://$host$request_uri;
}

# Inside the Docker network, all containers are trusted peers — so they can safely use plain HTTP.
# Client → HTTPS (443) → [gateway: Nginx terminates SSL]
#                      ↳ HTTP (80) → algo
#                      ↳ HTTP (80) → data